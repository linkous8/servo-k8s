#!/usr/bin/env python3
from __future__ import print_function

import copy
import importlib
import sys
import os
import errno
import subprocess
import time

from collections import Iterable

import json
import yaml
# import signal

from adjust import Adjust

json_enc = json.JSONEncoder(separators=(',', ':')).encode

# === constants
DESC_FILE = './config.yaml'
EXCLUDE_LABEL = 'optune.ai/exclude'
Gi = 1024 * 1024 * 1024
MEM_STEP = 64 * 1024 * 1024  # minimal useful increment in mem limit/reserve, bytes
CPU_STEP = 0.01  # 1% of a core (even though 1 millicore is the highest resolution supported by k8s)
MAX_MEM = 4 * Gi  # bytes, may be overridden to higher limit
MAX_CPU = 4.0  # cores
# MAX_REPLICAS = 1000 # arbitrary, TBD

# the k8s obj to which we make queries/updates:
DEPLOYMENT = 'deployment'


# DEPLOYMENT = 'deployment.v1.apps'  # new, not supported in 1.8 (it has v1beta1)


class ApiError(Exception):
    pass


class DeployError(Exception):  # raised when deploy ends in failed status
    pass


class ConfigError(Exception):  # user-provided descriptor not readable
    pass


def import_encoder_base():
    try:
        return importlib.import_module('encoders.base')
    except ImportError:
        raise ImportError('Unable to import base for encoders when handling `command` section.')


def kubectl(namespace, *args):
    cmd_args = ['kubectl']
    if not bool(int(os.environ.get('OPTUNE_USE_DEFAULT_NAMESPACE', '0'))):
        cmd_args.append('--namespace=' + namespace)
    # append conditional args as provided by env vars
    if os.getenv('OPTUNE_K8S_SERVER') is not None:
        cmd_args.append('--server=' + os.getenv('OPTUNE_K8S_SERVER'))
    if os.getenv('OPTUNE_K8S_TOKEN') is not None:
        cmd_args.append('--token=' + os.getenv('OPTUNE_K8S_TOKEN'))
    if bool(os.getenv('OPTUNE_K8S_SKIP_TLS_VERIFY', False)):
        cmd_args.append('--insecure-skip-tls-verify=true')
    # print("DEBUG: ns='{}', env='{}', r='{}', args='{}'".format(
    #     namespace, os.environ.get('OPTUNE_USE_DEFAULT_NAMESPACE', '???'), cmd_args, list(args)),
    #     file=sys.stderr)
    return cmd_args + list(args)


def k_get(namespace, qry):
    """run kubectl get and return parsed json output"""
    # this will raise exception if it fails:
    output = subprocess.check_output(kubectl(namespace, 'get', '--output=json', qry))
    output = output.decode('utf-8')
    output = json.loads(output)
    return output


def k_patch(namespace, typ, obj, patchstr):
    """run kubectl patch and return parsed json output"""
    # this will raise exception if it fails:
    cmd = kubectl(namespace, 'patch', '--output=json', typ, obj, '-p', patchstr)
    output = subprocess.check_output(cmd)
    output = output.decode('utf-8')
    output = json.loads(output)
    return output


def read_desc():
    """load the user-defined descriptor, returning a dictionary of the contents under the k8s top-level key, if any"""
    try:
        f = open(DESC_FILE)
        desc = yaml.load(f)
    except IOError as e:
        if e.errno == errno.ENOENT:
            raise ConfigError('configuration file {} does not exist'.format(DESC_FILE))
        raise ConfigError('cannot read configuration from {}: {}'.format(DESC_FILE, e.strerror))
    except yaml.error.YAMLError as e:
        raise ConfigError('syntax error in {}: {}'.format(DESC_FILE, str(e)))

    refer_tip = 'You can refer to a sample configuration in README.md.'
    assert bool(desc), 'Configuration file is empty.'
    assert 'k8s' in desc and desc['k8s'], 'No configuration were defined for K8s driver in config file {}. ' \
                                          'Please set up configuration for deployments under key "k8s". ' \
                                          '{}'.format(DESC_FILE, refer_tip)
    desc = desc['k8s']

    assert 'application' in desc and desc['application'], \
        'Section "application" was not defined in a configuration file. {}'.format(refer_tip)
    assert 'components' in desc['application'] and desc['application']['components'] is not None, \
        'Section "components" was not defined in a configuration file section "application". {}'.format(refer_tip)
    assert len(desc['application']['components']), 'No components were defined in a configuration file. ' \
                                                   'Please define at least one component. {}'.format(refer_tip)
    return desc


def numval(v, minv, maxv, step=1.0):
    """shortcut for creating linear setting descriptions"""
    return {'value': v, 'min': minv, 'max': maxv, 'step': step, 'type': 'range'}


def cpuunits(s):
    """convert a string for CPU resource (with optional unit suffix) into a number"""
    if s[-1] == 'm':  # there are no units other than 'm' (millicpu)
        return float(s[:-1]) / 1000.0
    return float(s)


# valid mem units: E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki
# nb: 'm' suffix found after setting 0.7Gi
mumap = {'E': 1000 ** 6, 'P': 1000 ** 5, 'T': 1000 ** 4, 'G': 1000 ** 3, 'M': 1000 ** 2, 'K': 1000, 'm': 1000 ** -1,
         'Ei': 1024 ** 6, 'Pi': 1024 ** 5, 'Ti': 1024 ** 4, 'Gi': 1024 ** 3, 'Mi': 1024 ** 2, 'Ki': 1024}


def memunits(s):
    """convert a string for memory resource (with optional unit suffix) into a number"""
    for u, m in mumap.items():
        if s.endswith(u):
            return float(s[:-len(u)]) * m
    return float(s)


def check_setting(name, settings):
    assert isinstance(settings, Iterable), 'Object "settings" passed to check_setting() is not iterable.'
    assert name not in settings, 'Setting "{}" has been define more than once. ' \
                                 'Please, check other config sections for setting duplicates.'.format(name)


def encoder_setting_name(setting_name, encoder_config):
    prefix = encoder_config['setting_prefix'] if 'setting_prefix' in encoder_config else ''
    return '{}{}'.format(prefix, setting_name)


def describe_encoder(value, config, exception_context='a describe phase of an encoder'):
    encoder_base = import_encoder_base()
    try:
        settings = encoder_base.describe(config, value or '')
        for name, setting in settings.items():
            yield (encoder_setting_name(name, config), setting)
    except BaseException as e:
        raise Exception('Error while handling {}: {}'.format(exception_context, str(e)))


def encode_encoder(settings, config, expected_type=None, exception_context='an encode phase of an encoder'):
    encoder_base = import_encoder_base()
    try:
        sanitized_settings = settings
        prefix = config.get('setting_prefix')
        if prefix:
            sanitized_settings = dict(map(lambda i: (i[0].lstrip(prefix), i[1]),
                                          filter(lambda i: i[0].startswith(prefix), settings.items())))
        encoded_value, encoded_settings = encoder_base.encode(config, sanitized_settings, expected_type=expected_type)
        encoded_settings = list(map(lambda setting_name: encoder_setting_name(setting_name, config), encoded_settings))
        return encoded_value, encoded_settings
    except BaseException as e:
        raise Exception('Error while handling {}: {}'.format(exception_context, str(e)))


def israngesetting(s):
    return s.get('type') == 'range'


def isenumsetting(s):
    return s.get('type') == 'enum'


def issetting(s):
    return isinstance(s, dict) and (israngesetting(s) or isenumsetting(s))


def raw_query(namespace, desc):
    """
    Read the list of deployments in a namespace and fill in data into desc.
    Both the input 'desc' and the return value are in the 'settings query response' format.
    NOTE only 'cpu', 'memory' and 'replicas' settings are filled in even if not present in desc.
    Other settings must have a description in 'desc' to be returned.
    """
    desc = copy.deepcopy(desc)

    app = desc['application']
    comps = app['components']

    dep_rsp = k_get(namespace, DEPLOYMENT)
    deps_list = dep_rsp['items']
    deps_dict = {dep['metadata']['name']: dep for dep in deps_list}
    for full_comp_name in comps.keys():
        dep_name = full_comp_name
        cont_name = None
        if '/' in dep_name:
            dep_name, cont_name = full_comp_name.split('/')
        assert dep_name in deps_dict, \
            'Could not find deployment "{}" defined for component "{}" in namespace "{}".' \
            ''.format(dep_name, full_comp_name, namespace)
        dep = deps_dict[dep_name]
        conts = dep['spec']['template']['spec']['containers']
        if cont_name is not None:
            conts_dict = {c['name']: c for c in conts}
            assert cont_name in conts_dict, \
                'Could not find container with name "{}" in deployment "{}" for component "{}" in namespace "{}".' \
                ''.format(cont_name, dep_name, full_comp_name, namespace)
            cont = conts_dict[cont_name]
        else:
            cont = conts[0]

        # skip if excluded by label
        try:
            labels = dep['metadata'].get('labels', {})
            if bool(int(labels.get(EXCLUDE_LABEL, '0'))):  # string value of 1 (non-0)
                continue
        except Exception as e:
            # TODO: add warning to annotations to be returned
            print('failed to parse exclude label for deployment {}: {}: {}; ignored'
                  ''.format(dep_name, type(e).__name__, str(e)), file=sys.stderr)
            # pass # fall through, ignore unparseable label

        # extract deployment settings
        # NOTE: generation, resourceVersion and uid can help detect changes
        # (also, to check PG's k8s code in oco)
        replicas = dep['spec']['replicas']

        # name, env, resources (limits { cpu, memory }, requests { cpu, memory })
        # FIXME: what to do if there's no mem reserve or limits defined?
        #        (a namespace can have a default mem limit, but that's not necessarily set, either)
        # (for now, we give the limit as 0, treated as 'unlimited' - AFAIK)
        # TODO: allow min/max/step overrides for mem/cpu settings in the config file
        comps[full_comp_name] = comp = comps[full_comp_name] or {}
        settings = comp.setdefault('settings', {})
        res = cont.get('resources')
        if res:
            # (value, min, max, step) all in GiB
            settings['mem'] = numval(v=memunits(res.get('limits', {}).get('memory', '0')) / Gi,
                                     minv=(settings.get('mem') or {}).get('min', MEM_STEP / Gi),
                                     maxv=(settings.get('mem') or {}).get('max', MAX_MEM / Gi),
                                     step=(settings.get('mem') or {}).get('step', MEM_STEP / Gi))
            # (value, min, max, step), all in CPU cores
            settings['cpu'] = numval(v=cpuunits(res.get('limits', {}).get('cpu', '0')),
                                     minv=(settings.get('cpu') or {}).get('min', CPU_STEP),
                                     maxv=(settings.get('cpu') or {}).get('max', MAX_CPU),
                                     step=(settings.get('cpu') or {}).get('step', CPU_STEP))
            # TODO: adjust min/max to include current values
            #       (e.g., increase mem_max to at least current if current > max)

        # FIXME: set replicas: can't actually be set for each container (the pod as a whole is replicated);
        #        for now we have no way of expressing this limitation in the setting descriptions
        # NOTE: setting min=max=current replicas, since there is no way to know what is allowed;
        #       use override descriptor to loosen range
        # settings['replicas'] = numval(v=replicas, minv=1, maxv=MAX_REPLICAS, step=1)
        settings['replicas'] = numval(v=replicas,
                                      minv=(settings.get('replicas') or {}).get('min', replicas),
                                      maxv=(settings.get('replicas') or {}).get('max', replicas),
                                      step=(settings.get('replicas') or {}).get('step', 1))

        # current settings of custom env vars (NB: type conv needed for numeric values!)
        cont_env_list = cont.get('env', [])
        cont_env_dict = {i['name']: i['value'] for i in cont_env_list}

        env = comp.get('env')
        if env:
            for en, ev in env.items():
                check_setting(en, settings)
                assert isinstance(ev, dict), 'Setting "{}" in section "env" of a config file is not a dictionary.'
                if 'encoder' in ev:
                    for name, setting in describe_encoder(cont_env_dict.get(en), ev['encoder'],
                                                          exception_context='an environment variable {}'
                                                                            ''.format(en)):
                        check_setting(name, settings)
                        settings[name] = setting
                if issetting(ev):
                    defval = ev.pop('default', None)
                    val = cont_env_dict.get(en, defval)
                    val = float(val) if israngesetting(ev) and isinstance(val, (int, str)) else val
                    assert val is not None, 'Environment variable "{}" does not have a current value defined and ' \
                                            'neither it has a default value specified in a config file. ' \
                                            'Please, set current value for this variable or adjust the ' \
                                            'configuration file to include its default value.' \
                                            ''.format(en)
                    val = {**ev, 'value': val}
                    settings[en] = val
            # Remove section "env" from final descriptor
            del comp['env']

        command = comp.get('command')
        if command:
            if command.get('encoder'):
                for name, setting in describe_encoder(cont.get('command', []), command['encoder'],
                                                      exception_context='a command section'):
                    check_setting(name, settings)
                    settings[name] = setting
                # Remove section "command" from final descriptor
            del comp['command']

    return desc, deps_list


# DEBUG:
def ydump(fn, data):
    f = open(fn, 'w')
    yaml.dump(data, f)
    f.close()


def dbg_log(*args):
    if os.getenv('TDR_DEBUG_LOG'):
        print(*args, file=sys.stderr)


def query(namespace, desc):
    desc_with_values, _ = raw_query(namespace, desc)
    return desc_with_values


class Waiter(object):
    """an object for use to poll and wait for a condition;
    use:
        w = waiter(max_time, delay)
        while w.wait():
            if test_condition(): break
        if w.expired:
            raise Hell
    """

    def __init__(self, timeout, delay=1):
        self.timefn = time.time  # change that on windows to time.clock
        self.start = self.timefn()
        self.end = self.start + timeout
        self.delay = delay
        self.expired = False

    def wait(self):
        time.sleep(self.delay)  # TODO: add support for increasing delay over time
        self.expired = self.end < self.timefn()
        return not self.expired


def test_dep_generation(dep, g):
    """check if the deployment status indicates it has been updated to the given generation number"""
    return dep['status']['observedGeneration'] == g


def test_dep_progress(dep):
    """ check if the deployment has reached final successful status """
    dbg_log('test_dep_progress:')
    for co in dep['status']['conditions']:
        dbg_log('... condition type {}, reason {}, status {}, message {}'
                ''.format(co.get('type'), co.get('reason'), co.get('status'), co.get('message')))
        # FIXME: TBD: completion may have different final 'reason' statuses,
        #             this is the only one known for now, to be researched.
        if co['type'] == 'Progressing':
            return co['reason'] == 'NewReplicaSetAvailable'
        # FIXME: NB: the above was not showing up consistently on k8s 1.8 but this did:
        if co['type'] == 'Available' and co['reason'] == 'MinimumReplicasAvailable':
            return co.get('status') == 'True'  # the string "True", not a bool value
    return None  # can't tell


# FIXME: observed a patch trigger spontaneous reduction in replica count!
#        (happened when update was attempted without replica count changes and
#         2nd replica was not schedulable according to k8s)
# NOTE: update of 'observedGeneration' does not mean that the 'deployment' object is done updating; also checking
#       readyReplicas or availableReplicas in status does not help (these numbers may be for OLD replicas, if the new
#       replicas cannot be started at all). We check for a 'Progressing' condition with a specific 'reason' code as an
#       indication that the deployment is fully updated.
# NOTE: The 'kubectl rollout status' command relies only on the deployment object - therefore info in it should be
#       sufficient to track progress.
# FIXME: ? do we need to use --to-revision with the undo command?
# FIXME: cpu request above 0.05 fails for 2 replicas on minikube. Not understood.
#        (NOTE also that setting cpu_limit without specifying request causes request to be set to the same value,
#         except if limit is very low - in that case, request isn't set at all)

def wait_for_update(namespace, obj, patch_gen, print_progress, c=0, t=1):
    """wait for a patch to take effect. obj is the deployment name, patch_gen is the object
       generation immediately after the patch was applied (should be a k8s obj with "kind":"Deployment")"""
    wait_for_gen = 5  # time to wait for object update ('observedGeneration')
    wait_for_progress = 40  # time to wait for rollout to complete

    part = 1.0 / float(t)
    # p = 0.0
    # m = 'updating {}'.format(obj)

    dbg_log('waiting for update: deployment {}, generation {}'.format(obj, patch_gen))

    # NOTE: best to implement this with a 'watch', not using an API poll!

    # ?watch=1 & resourceVersion = metadata[resourceVersion], timeoutSeconds=t,
    # --raw=''
    # GET /apis/apps/v1/namespaces/{namespace}/deployments

    w = Waiter(wait_for_gen, 2)
    while w.wait():
        # NOTE: no progress prints here, this wait should be short
        r = k_get(namespace, DEPLOYMENT + '/' + obj)

        # ydump('tst_wait{}_output_{}.yaml'.format(rc, obj), r)
        # rc = rc + 1
        if test_dep_generation(r, patch_gen):
            break

    if w.expired:
        raise DeployError('update of {} failed, timed out waiting for k8s object update'.format(obj))

    dbg_log('waiting for progress: deployment {}, generation {}'.format(obj, patch_gen))

    p = 1.0  # instance progress phase (out of 3)
    phases = 3.0

    m = 'waiting for progress from k8s {}'.format(obj)

    w = Waiter(wait_for_progress, 2)
    while w.wait():
        r = k_get(namespace, DEPLOYMENT + '/' + obj)
        print_progress(int((float(c) + p / phases) * part * 100), m)
        if not test_dep_progress(r):
            continue

        available_replicas = r['status'].get('availableReplicas', 0)  # use get(), item is not always present!
        dbg_log('... checking replica count: spec {}, status {}'.format(r['spec']['replicas'], available_replicas))

        # NOTE: JIC: this shouldn't wait anymore, if dep. is not 'progressing' anymore
        p = 2.0
        m = 'waiting for replicas update {}'.format(obj)
        if available_replicas >= r['spec']['replicas']:
            # print('WAITED', time.time() - w.start, file=sys.stderr)
            return  # all done

    # loop ended, timed out:
    raise DeployError('update of {} failed: timed out waiting for replicas to come up'.format(obj))


resource_paths = {'mem': ('limits', 'memory'), 'cpu': ('limits', 'cpu')}


def set_resource(cont_patch, sn, sv):
    k1, k2 = resource_paths[sn]
    if sn == 'mem':
        sv = str(sv) + 'Gi'  # internal memory representation is in GiB
    else:
        sv = str(sv)
    cont_patch.setdefault('resources', {}).setdefault(k1, {})[k2] = sv


def setting_value(x):
    if isinstance(x, dict) and 'value' in x:
        return x['value']
    return x


def update(namespace, desc, data, print_progress):
    # NOTE: we'll need the raw k8s api data to see the container names (setting names for a single-container
    #       pod will include only the deployment(=pod) name, not the container name)
    _, raw = raw_query(namespace, desc)

    # convert k8s list of deployments into map
    raw = {dep['metadata']['name']: dep for dep in raw}

    comp_patches = {}

    # FIXME: NB: app-wide settings not supported

    # FIXME: off-spec; step-down in data if a 'state' key is provided at the top.
    if 'state' in data:
        data = data['state']

    for comp_name, comp_data in data.get('application', {}).get('components', {}).items():
        settings_data = comp_data.get('settings', {})
        if not settings_data:
            continue
        cont_patches = {}
        replicas = None
        comp_desc = desc['application']['components'].get(comp_name) or {}

        # Define deployment name and container name, and verify it's existence
        cont_name = None
        dep_name = comp_name
        if '/' in dep_name:
            dep_name, cont_name = dep_name.split('/', 1)
        assert dep_name in raw, 'Cannot find deployment with name "{}" for component "{}" in namespace "{}"' \
                                ''.format(dep_name, comp_name, namespace)
        cont_name = cont_name or raw[dep_name]['spec']['template']['spec']['containers'][0]['name']
        available_conts = set(c['name'] for c in raw[dep_name]['spec']['template']['spec']['containers'])
        assert cont_name in available_conts, 'Could not find container with name "{}" in deployment "{}" ' \
                                             'for component "{}" in namespace "{}".'.format(cont_name, dep_name,
                                                                                            comp_name, namespace)
        cont_patch = cont_patches.setdefault(cont_name, {})

        command = comp_desc.get('command')
        if command:
            if command.get('encoder'):
                cont_patch['command'], encoded_settings = encode_encoder(settings_data, command['encoder'],
                                                                         expected_type=list)

                # Prevent encoded settings from further processing
                for setting in encoded_settings:
                    del settings_data[setting]

        env = comp_desc.get('env')
        if env:
            for en, ev in env.items():
                if ev.get('encoder'):
                    val, encoded_settings = encode_encoder(settings_data, ev['encoder'], expected_type=str)
                    cont_patch.setdefault('env', []).append({'name': en, 'value': val})

                    # Prevent encoded settings from further processing
                    for setting in encoded_settings:
                        del settings_data[setting]
                elif issetting(ev):
                    cont_patch.setdefault('env', []).append({'name': en, 'value': str(settings_data[en]['value'])})
                    del settings_data[en]

        # Settings and env vars
        for name, value in settings_data.items():
            value = setting_value(value)  # compatibility: allow a scalar, but also work with {"value": {anything}}
            if name in ('mem', 'cpu'):
                set_resource(cont_patch, name, value)
                continue
            elif name == 'replicas':
                replicas = int(value)

        comp_patch = comp_patches.setdefault(comp_name, {})
        if cont_patches:  # convert to array
            patches = comp_patch \
                .setdefault('spec', {}) \
                .setdefault('template', {}) \
                .setdefault('spec', {}) \
                .setdefault('containers', [])
            for n, v in cont_patches.items():
                v['name'] = n
                patches.append(v)

        if replicas is not None:
            comp_patch.setdefault('spec', {})['replicas'] = replicas

    if not comp_patches:
        raise Exception('No components were defiend in a configuration file. Cannot proceed with an adjustment.')

    # NOTE: optimization possible: apply all patches first, then wait for them to complete
    #       (significant if making many changes at once!)

    # NOTE: it seems there's no way to update multiple resources with one 'patch' command
    #       (though -f accepts a directory, not sure how -f=dir works; maybe all listed resources
    #        get the *same* patch from the cmd line - not what we want)

    # execute patch commands
    patched_count = 0
    for n, v in comp_patches.items():
        # ydump('tst_before_output_{}.yaml'.format(n), k_get(namespace, DEPLOYMENT + '/' + n))
        # run: kubectl patch deployment[.v1.apps] $n -p "{jsondata}"
        patchstr = json_enc(v)
        patch_r = k_patch(namespace, DEPLOYMENT, n, patchstr)
        if test_dep_generation(patch_r, patch_r['metadata']['generation']) and test_dep_progress(patch_r):
            # patch made no changes, skip wait_for_update:
            patched_count = patched_count + 1
            continue

        # ydump('tst_patch_output_{}.yaml'.format(n), patch_r)

        # wait for update to complete (and print progress)
        try:
            wait_for_update(namespace, n, patch_r['metadata']['generation'], print_progress, patched_count,
                            len(comp_patches))
        except DeployError as e:
            if not os.getenv('TDR_DEBUG_NO_UNDO'):
                try:
                    subprocess.call(['kubectl', 'rollout', 'undo', DEPLOYMENT + '/' + n])
                    # FIXME: use the kubectl() function so that we pickup any
                    #        appended cmdline args, e.g., namespace, server, token etc.
                except subprocess.CalledProcessError:
                    # TODO: progress msg with warning
                    print('undo for {} failed: {}'.format(n, e), file=sys.stderr)
            raise
        patched_count = patched_count + 1

    # update() return


# cancel not supported
# def cancel(signum, frame):
#     if not wait_in_progress:
#         sys_exit(1)
#     print('aborting operation...', file=sys.stderr)


VERSION = '1.2'


class K8sAdjust(Adjust):

    def _progress(self, progress, message):
        """adapter for the default base class implementation of progress message"""
        self.progress = progress
        self.print_progress(message=message)

    def query(self):
        try:
            desc = read_desc()
        except (ConfigError, AssertionError) as e:
            print(json.dumps({'error': 'config', 'class': 'config', 'message': str(e)}))
            sys.exit(3)
        desc.pop('driver', None)
        try:
            output = query(self.app_id, desc)
        except (ApiError, DeployError) as e:
            print(json.dumps({'error': e.__class__.__name__, 'class': 'failure', 'message': str(e)}))
            sys.exit(3)
        return output

    def adjust(self, data=None):
        try:
            try:
                desc = read_desc()
            except (ConfigError, AssertionError) as e:
                print(json.dumps({'error': 'config', 'class': 'config', 'message': str(e)}))
                sys.exit(3)
            update(self.app_id, desc, data, self._progress)
        except (ApiError, DeployError) as e:
            print(json.dumps({'error': e.__class__.__name__, 'class': 'failure', 'message': str(e)}))
            sys.exit(3)
        except ConfigError as e:
            print(json.dumps({'error': 'config', 'class': 'config', 'message': str(e)}))
            sys.exit(3)
        # all other exceptions: default handler - stack trace and sys.exit(1)


if __name__ == '__main__':
    # signal.signal(signal.SIGUSR1, cancel)
    # signal.signal(signal.SIGTERM, cancel)
    # signal.signal(signal.SIGINT, cancel)

    driver = K8sAdjust(
        VERSION,
        'K8s driver for OCO servo.\n'
        'Note: set OPTUNE_USE_DEFAULT_NAMESPACE=1 environment var when embedded into app',
        supports_cancel=False,
        progress_interval=None,
    )
    driver.run()

# TODO: TBD: no support for multiple apps with different descriptors (desc file /app.yaml is not app-specific)
