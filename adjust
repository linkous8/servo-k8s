#!/usr/bin/env python3
from __future__ import print_function

import copy
import importlib
import sys
import os
import errno
import subprocess
import time

# import re
from collections import Iterable, OrderedDict

import json
import yaml
# import signal

from adjust import Adjust, AdjustError

json_enc = json.JSONEncoder(separators=(",", ":")).encode

# === constants
DESC_FILE = "./config.yaml"
EXCLUDE_LABEL = 'optune.ai/exclude'
Gi = 1024*1024*1024
MEM_STEP = 64*1024*1024 # minimal useful increment in mem limit/reserve, bytes
CPU_STEP = 0.01 # 1% of a core (even though 1 millicore is the highest resolution supported by k8s)
MAX_MEM = 4*Gi # bytes, may be overridden to higher limit
MAX_CPU = 4.0  # cores
#MAX_REPLICAS=1000 # arbitrary, TBD

# the k8s obj to which we make queries/updates:
DEPLOYMENT = "deployment"
#DEPLOYMENT="deployment.v1.apps" #new, not supported in 1.8 (it has v1beta1)

class ConfigError(Exception): # user-provided descriptor not readable
    pass


def import_encoder_base():
    try:
        return importlib.import_module('encoders.base')
    except ImportError:
        raise ImportError('Unable to import base for encoders when handling `command` section.')

# === compute hash of arbitrary data struct
# (copied inline from skopos/.../plugins/spec_hash_helper.py)
import hashlib

def _dbg(*data):
    with open('/skopos/plugins/dbg.log', 'a') as f:
        print(data, file=f)

def get_hash(data):
    """md5 hash of Python data. This is limited to scalars that are convertible to string and container
    structures (list, dict) containing such scalars. Some data items are not distinguishable, if they have
    the same representation as a string, e.g., hash(b'None') == hash('None') == hash(None)"""
    # _dbg("get_hash", data)
    hasher = hashlib.md5()
    dump_container(data, hasher.update)
    return hasher.hexdigest()


def dump_container(c, func):
    """stream the contents of a container as a string through a function
    in a repeatable order, suitable, e.g., for hashing
    """
    #
    if isinstance(c, dict): # dict
        func("{".encode('utf-8'))
        for k in sorted(c):# for all repeatable
            func("{}:".format(k).encode('utf-8'))
            dump_container(c[k], func)
            func(",".encode('utf-8'))
        func("}".encode('utf-8'))
    elif isinstance(c, list): # list
        func("[".encode('utf-8'))
        for k in c:# for all repeatable
            dump_container(k, func)
            func(",".encode('utf-8'))
        func("]".encode('utf-8'))
    else: # everything else
        if isinstance(c, type(b'')):
            pass # already a stream, keep as is
        elif isinstance(c, str):
            # encode to stream explicitly here to avoid implicit encoding to ascii
            c = c.encode('utf-8')
        else:
            c = str(c).encode('utf-8')  # convert to string (e.g., if integer)
        func(c)         # simple value, string or convertible-to-string

# ===

def kubectl(namespace, *args):
    r = ['kubectl']
    if not bool(int(os.environ.get('OPTUNE_USE_DEFAULT_NAMESPACE', '0'))):
        r.append('--namespace=' + namespace)

    # append conditional args as provided by env vars
    if os.getenv('OPTUNE_K8S_SERVER') is not None:
        r.append('--server=' + os.getenv('OPTUNE_K8S_SERVER'))
    if os.getenv('OPTUNE_K8S_TOKEN') is not None:
        r.append('--token=' + os.getenv('OPTUNE_K8S_TOKEN'))
    if bool(os.getenv('OPTUNE_K8S_SKIP_TLS_VERIFY', False)):
        r.append('--insecure-skip-tls-verify=true')

    print("DEBUG: ns='{}', env='{}', r='{}', args='{}'".format(
        namespace, os.environ.get('OPTUNE_USE_DEFAULT_NAMESPACE', '???'), r, list(args)),
        file=sys.stderr)

    return r + list(args)

def k_get(namespace, qry):
    '''run kubectl get and return parsed json output'''

    if not isinstance(qry, list):
        qry = [qry]
    # this will raise exception if it fails:
    r = subprocess.check_output(kubectl(namespace, 'get', '--output=json', *qry))
    r = r.decode('utf-8')
    r = json.loads(r)
    return r

def k_patch(namespace, typ, obj, patchstr):
    '''run kubectl patch and return parsed json output'''

    # this will raise exception if it fails:
    cmd = kubectl(namespace, "patch", "--output=json", typ, obj, "-p", patchstr)
    r = subprocess.check_output(cmd)
    r = r.decode('utf-8')
    r = json.loads(r)
    return r

def read_desc():
    '''load the user-defined descriptor, returning a dictionary of the contents under the k8s top-level key, if any'''

    try:
        f = open(DESC_FILE)
        d = yaml.load(f)
    except IOError as e:
        if e.errno == errno.ENOENT:
            return {} # only if 'file not found'
        raise ConfigError("cannot read configuration from {}:{}".format(DESC_FILE, e.strerror))
    except yaml.error.YAMLError as e:
        raise ConfigError("syntax error in {}: {}".format(DESC_FILE, str(e)))
    # everything else: crash

    return d.get('k8s', {})

def numval(v, min, max, step=1):
    """shortcut for creating linear setting descriptions"""
    return {"value":v, "min":min, "max":max, "step":step, "type": "range"}

def cpuunits(s):
    '''convert a string for CPU resource (with optional unit suffix) into a number'''
    if s[-1] == "m": # there are no units other than 'm' (millicpu)
        return float(s[:-1])/1000.0
    return float(s)

# valid mem units: E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki
# nb: 'm' suffix found after setting 0.7Gi
mumap = {"E":1000**6,  "P":1000**5,  "T":1000**4,  "G":1000**3,  "M":1000**2,  "K":1000, "m":1000**-1,
         "Ei":1024**6, "Pi":1024**5, "Ti":1024**4, "Gi":1024**3, "Mi":1024**2, "Ki":1024}
def memunits(s):
    '''convert a string for memory resource (with optional unit suffix) into a number'''
    for u, m in mumap.items():
        if s.endswith(u):
            return float(s[:-len(u)]) * m
    return float(s)

def check_setting(name, settings):
    assert isinstance(settings, Iterable), 'Object "settings" passed to check_setting() is not iterable.'
    assert name not in settings, 'Setting "{}" has been define more than once. ' \
                                 'Please, check other config sections for setting duplicates.'.format(name)

def encoder_setting_name(name, config):
    prefix = config['setting_prefix'] if 'setting_prefix' in config else ''
    return '{}{}'.format(prefix, name)

def describe_encoder(value, config, context='a describe phase of an encoder'):
    encoder_base = import_encoder_base()
    try:
        settings = encoder_base.describe(config, value or '')
        for name, setting in settings.items():
            yield (encoder_setting_name(name, config), setting)
    except BaseException as e:
        raise Exception('Error while handling {}: {}'.format(context, str(e)))

def encode_encoder(settings, config, expected_type=None, context='an encode phase of an encoder'):
    encoder_base = import_encoder_base()
    try:
        sanitized_settings = settings
        prefix = config.get('setting_prefix')
        if prefix:
            sanitized_settings = dict(map(lambda i: (i[0].lstrip(prefix), i[1]),
                                          filter(lambda i: i[0].startswith(prefix), settings.items())))
        encoded_value, encoded_settings = encoder_base.encode(config, sanitized_settings, expected_type=expected_type)
        encoded_settings = list(map(lambda setting_name: encoder_setting_name(setting_name, config), encoded_settings))
        return encoded_value, encoded_settings
    except BaseException as e:
        raise Exception('Error while handling {}: {}'.format(context, str(e)))

def israngesetting(s):
    return s.get('type') == 'range'

def isenumsetting(s):
    return s.get('type') == 'enum'

def issetting(s):
    return isinstance(s, dict) and (israngesetting(s) or isenumsetting(s))

def check_component_section(component, name):
    sec = component.get(name)
    if sec is not None:
        assert isinstance(component, dict), 'Config section "env" should be a dictionary.'
    return sec

def raw_query(appname, desc=None):
    '''read the list of deployments for appname and fill in data into desc (or create blank desc,
    if not provided).  both the input 'desc' and the return value are in the 'settings query
    response' format. NOTE the input 'desc' may also have a top-level key 'whitelist_deployment_names'
    used to limit tunable deployments.
    NOTE only cpu/memory settings and replicas are filled in even if not present in desc.
    Other settings must have a description in 'desc' to be returned.
    '''
    if isinstance(desc, dict):
        desc = copy.deepcopy(desc)
    if not desc:
        desc = {"application":{}}
    elif not desc.get("application"):
        desc["application"] = {}
    comps = desc["application"].setdefault("components", {})

    cfg = desc.pop("control", {}) # FIXME TODO - query doesn't receive data from remote, only the local cfg can be used; where in the data should the "control" section really be?? note, [userdata][deployment] sub-keys for specifying the 'reference' app means we have to have that 'reference' as a single deployment and it has to be excluded from enumeration as an 'adjustable' component, using the whitelist.
    refapp = cfg.get("userdata", {}).get("deployment", None)
    mon_data = {}
    if refapp:
        d2 = desc.copy()
        c2 = copy.deepcopy(cfg)
        c2["userdata"].pop("deployment", None)
        d2["control"] = c2
        d2["whitelist_deployment_names"] = [refapp]
        d2["application"] = {"components":{}} # empty it, we want only what's found automatically (the ref deployment)
        try:
            refqry, _ = raw_query(appname, d2)
        except AdjustError as e:
            raise AdjustError(str(e), status="aborted", reason="ref-app-unavailable")
        # let other exceptions go unchanged

        # TODO: maybe something better than a sum is needed here, some multi-component scale events could end up modifying scale counts without changing the overall sum
        replicas_sum = sum((c["settings"]["replicas"]["value"] for c in refqry["application"]["components"].values()))
        refqry = refqry["monitoring"] # we don't need other data from refqry any more
        mon_data = {"ref_spec_id": refqry["spec_id"],
                   "ref_runtime_id": refqry["runtime_id"],
                   "ref_version_id": refqry["version_id"],
                   "ref_runtime_count": replicas_sum}

    # pop list of valid deployment names, if provided, from desc
    whitelist_dep_names = desc.pop("whitelist_deployment_names", None)

    d = k_get(appname, DEPLOYMENT)
    # note d["Kind"] should be "List"
    d = d["items"]
    if not d: # NOTE we don't distinguish the case when the namespace doesn't exist at all or is just empty (k8s will return an empty list whether or not it exists)
        raise AdjustError("application '{}' does not exist or has no components".format(appname),
            status="aborted", reason="app-unavailable") # NOTE not a documented 'reason'
    raw_specs = {}
    imgs = {}
    runtime_ids = {}
    # ?? TODO: is it possible to have an item in 'd' with "kind" other than "Deployment"? (likely no)
    #          is it possible to have replicas == 0 (and how do we represent that, if at all)
    for dep in d:
        # selector for pods, NOTE this relies on having a equality-based label selector,
        # k8s seems to support other types, I don't know what's being used in practice.
        try:
            sel = dep["spec"]["selector"]["matchLabels"]
        except KeyError:
            raise AdjustError("only deployments with matchLabels selector are supported, found selector: {}".format(repr(dep["spec"].get("selector",{}))),
            status="aborted", reason="app-unavailable") # NOTE not a documented 'reason'
        # convert to string suitable for 'kubect -l labelsel'
        sel = ','.join(("{}={}".format(k,v) for k,v in sel.items()))

        # extract deployment name
        dname = dep["metadata"]["name"] # better be present; if not, we could use labels.app or spec.selector.matchLabels.app (but that's dependent on the developer having used the 'app' label to tag the deployment's pods).

        # skip if excluded from list of valid deployment names
        if whitelist_dep_names is not None and dname not in whitelist_dep_names:
            continue

        # skip if excluded by label
        try:
            if bool(int(dep["metadata"].get("labels", {}).get(EXCLUDE_LABEL, "0"))): # string value of 1 (non-0)
                continue
        except ValueError as e: # int() is the only thing that should trigger exceptions here
            #TODO add warning to annotations to be returned
            print("failed to parse exclude label for deployment {}: {}: {}; ignored".format(dname, type(e).__name__, str(e)), file=sys.stderr)
            # pass # fall through, ignore unparseable label

        # list of pods, for runtime_id
        pods = k_get(appname, ["-l", sel, "pods"])
        pods = pods["items"]
        runtime_ids[dname] = [pod["metadata"]["uid"] for pod in pods]

        # extract deployment settings
        # NOTE: generation, resourceVersion and uid can help detect changes
        # (also, to check PG's k8s code in oco)
        replicas = dep["spec"]["replicas"]
        tmplt_spec = dep["spec"]["template"]["spec"]
        raw_specs[dname] = tmplt_spec # save for later, used to checksum all specs
        for c in tmplt_spec["containers"]:
            # name, env, resources (limits { cpu, memory }, requests { cpu, memory })
            if len(tmplt_spec["containers"]) == 1:
                cn = dname
            else:
                cn = dname+"/"+c["name"]
            # FIXME: what to do if there's no mem reserve or limits defined? (a namespace can have a default mem limit, but that's not necessarily set, either)
            # (for now, we give the limit as 0, treated as 'unlimited' - AFAIK)
            # TODO: allow min/max/step overrides for mem/cpu settings in the config file
            imgs[cn] = c["image"] # FIXME, is this always defined?
            comp = comps.setdefault(cn, {})
            settings = comp.setdefault("settings", {})
            settings = comp['settings'] = OrderedDict(settings)
            r = c.get("resources")
            if r:
                settings["mem"] = numval(memunits(r.get("limits", {}).get("memory", "0"))/Gi, MEM_STEP/Gi, MAX_MEM/Gi, MEM_STEP/Gi) # (value,min,max,step) all in GiB
                settings["cpu"] = numval(cpuunits(r.get("limits", {}).get("cpu", "0")), CPU_STEP, MAX_CPU, CPU_STEP) # (value,min,max,step), all in CPU cores
                #TODO: adjust min/max to include current values (e.g., increase mem_max to at least current if current > max)

            # set replicas: FIXME: can't actually be set for each container (the pod as a whole is replicated); for now we have no way of expressing this limitation in the setting descriptions
            # note: setting min=max=current replicas, since there is no way to know what is allowed; use override descriptor to loosen range
            #settings["replicas"] = numval(replicas, 1, MAX_REPLICAS, 1)
            settings["replicas"] = numval(replicas, replicas, replicas, 1)

            # current settings of custom env vars (NB: type conv needed for numeric values!)
            cont_env_list = c.get("env",[])
            cont_env_dict = {i['name']: i['value'] for i in cont_env_list}
            for ev in cont_env_list:
                # skip env vars that match the pre-defined setting names above
                if ev["name"] in ("mem", "cpu", "replicas"):
                    continue
                if ev["name"] in settings:
                    s = settings[ev["name"]]
                    typ = s.get("type", "range")
                    if typ in ("range", "linear"):
                        try:
                            s["value"] = float(ev["value"])
                        except ValueError:
                            raise ConfigError("invalid value found in environment {}={}, it was expected to be numeric".format(ev["name"], ev["value"]))
                    else:
                        s["value"] = ev["value"]

            env = check_component_section(comp, 'env')
            if env:
                for en, ev in env.items():
                    check_setting(en, settings)
                    assert isinstance(ev, dict), 'Setting "{}" in section "env" of a config file is not a dictionary.'
                    if 'encoder' in ev:
                        for name, setting in describe_encoder(cont_env_dict.get(en), ev['encoder'],
                                                              context='an environment variable {}'.format(en)):
                            check_setting(name, settings)
                            settings[name] = setting
                    if issetting(ev):
                        defval = ev.pop('default', None)
                        val = cont_env_dict.get(en, defval)
                        val = float(val) if israngesetting(ev) and isinstance(val, (int, str)) else val
                        val = {**ev, 'value': val}
                        settings[en] = val
                # Remove section "env" from final descriptor
                del comp['env']

            command = check_component_section(comp, 'command')
            if command:
                if command.get('encoder'):
                    for name, setting in describe_encoder(c.get('command', []), command['encoder'],
                                                          context='a command section'):
                        check_setting(name, settings)
                        settings[name] = setting
                    # Remove section "command" from final descriptor
                del comp['command']


    if not runtime_ids:
        raise AdjustError("application '{}' has no components".format(appname),
            status="aborted", reason="app-unavailable") # NOTE not a documented 'reason'

    # app state data
    # (NOTE we strip the component names because our (single-component) 'reference' app will necessarily have a different component name)
    # this should be resolved by complete re-work, if we are to support 'reference' app in a way that allows multiple components
    raw_specs = [raw_specs[k] for k in sorted(raw_specs.keys())]
    imgs = [imgs[k] for k in sorted(imgs.keys())]
    mon_data.update({"spec_id": get_hash(raw_specs),
                  "runtime_id": get_hash(runtime_ids),
                  "version_id": get_hash(imgs),
                   # "runtime_count": replicas_sum
                 })

    desc["monitoring"] = mon_data

    return desc, d

# DEBUG:
def ydump(fn, data):
    f = open(fn, "w")
    yaml.dump(data, f)
    f.close()

def dbg_log(*args):
    if os.getenv("TDR_DEBUG_LOG"):
        print(*args, file=sys.stderr)

def query(appname, desc=None):
    r, _ = raw_query(appname, desc)
    return r

class waiter(object):
    """an object for use to poll and wait for a condition;
    use:
        w = waiter(max_time, delay)
        while w.wait():
            if test_condition(): break
        if w.expired:
            raise Hell
    """
    def __init__(self, timeout, delay=1):
        self.timefn = time.time # change that on windows to time.clock
        self.start = self.timefn()
        self.end = self.start+timeout
        self.delay = delay
        self.expired = False

    def wait(self):
        time.sleep(self.delay) # TODO: add support for increasing delay over time
        self.expired = self.end < self.timefn()
        return not self.expired


def test_dep_generation(dep, g):
    """ check if the deployment status indicates it has been updated to the given generation number"""
    return dep["status"]["observedGeneration"] == g

def test_dep_progress(dep):
    """check if the deployment object 'dep' has reached final successful status
    ('dep' should be the data returned by 'kubectl get deployment' or the equivalent API call, e.g.,
    GET /apis/(....)/namespaces/:ns/deployments/my-deployment-name).
    This tests the conditions[] array and the replica counts and converts the data to a simplified status, as follows:
    - if the deployment appears to be in progress and k8s is still waiting for updates from the controlled objects (replicasets and their pods),
      return a tuple (x, ""), where x is the fraction of the updated instances (0.0 .. 1.0, excluding 1.0).
    - if the deployment has completed, return (1.0, "")
    - if the deployment has stalled or failed, return (x, "(errormsg)"), with an indication of the
      detected failure (NOTE: in k8s, the 'stall' is never final and could be unblocked by change
      of resources or other modifications of the cluster not related to the deployment in question,
      but we assume that the system is operating under stable conditions and there won't be anyone
      or anything that can unblock such a stall)
    """
    dbg_log('test_dep_progress:')
    spec_replicas = dep["spec"]["replicas"] # this is what we expect as target
    error = None
    progress_final = None
    dep_status = dep["status"]
    for co in dep_status["conditions"]:
        dbg_log('... condition type {}, reason {}, status {}, message {}'.format(co.get('type'), co.get('reason'), co.get('status'), co.get('message')))
        if co["type"] == "Progressing":
            if co["status"] == "True" and co["reason"] == "NewReplicaSetAvailable":
                # if the replica set was updated, test the replica counts
                if dep_status.get("updatedReplicas", None) == spec_replicas: # update complete, check other counts
                    if (dep_status.get("availableReplicas", None) == spec_replicas and
                        dep_status.get("readyReplicas", None) == spec_replicas):
                        return (1.0, "") # done
            elif co["status"] == "False": # failed
                return (dep_status.get("updatedReplicas", 0)/spec_replicas, co["reason"] + ", " + co.get("message", ""))
            # otherwise, assume in-progress
        elif co["type"] == "ReplicaFailure":
            # note if this status is found, we report failure early here, before k8s times out
            return (dep_status.get("updatedReplicas", 0)/spec_replicas, co["reason"] + ", " + co.get("message", ""))

    # no errors and not complete yet, assume in-progress
    # (NOTE if "Progressing" condition isn't found, but updated replicas is good, we will return 100% progress; in this case check that other counts are correct, as well!
    progress = dep_status.get("updatedReplicas", 0)/spec_replicas
    if progress == 1.0:
        if (dep_status.get("availableReplicas", None) == spec_replicas and
                        dep_status.get("readyReplicas", None) == spec_replicas):
            return (1.0, "") # all good
        progress = 0.99 # available/ready counts aren't there - don't report 100%, wait loop will contiune until ready or time out
    return (progress, "")


# FIXME: observed a patch trigger spontaneous reduction in replica count! (happened when update was attempted without replica count changes and 2nd replica was not schedulable according to k8s)
# NOTE: update of 'observedGeneration' does not mean that the 'deployment' object is done updating; also checking readyReplicas or availableReplicas in status does not help (these numbers may be for OLD replicas, if the new replicas cannot be started at all). We check for a 'Progressing' condition with a specific 'reason' code as an indication that the deployment is fully updated.
# The 'kubectl rollout status' command relies only on the deployment object - therefore info in it should be sufficient to track progress.
# ? do we need to use --to-revision with the undo command?
# FIXME: cpu request above 0.05 fails for 2 replicas on minikube. Not understood. (NOTE also that setting cpu_limit without specifying request causes request to be set to the same value, except if limit is very low - in that case, request isn't set at all)

def wait_for_update(appname, obj, patch_gen, print_progress, c=0, t=1, wait_for_progress = 40):
    """wait for a patch to take effect. appname is the namespace, obj is the deployment name, patch_gen is the object generation immediately after the patch was applied (should be a k8s obj with "kind":"Deployment")"""
    wait_for_gen = 5 # time to wait for object update ('observedGeneration')
    # wait_for_progress = 40 # time to wait for rollout to complete

    part = 1.0/float(t)
    m = "updating {}".format(obj)

 #FIXME FIXME: configurable timeout
    dbg_log('waiting for update: deployment {}, generation {}'.format(obj, patch_gen))

    # NOTE: best to implement this with a 'watch', not using an API poll!
# ?watch=1 & resourceVersion = metadata[resourceVersion], timeoutSeconds=t,
# --raw=''
#GET /apis/apps/v1/namespaces/{namespace}/deployments

    w = waiter(wait_for_gen, 2)
    while w.wait():
        # no progress prints here, this wait should be short
        r = k_get(appname, DEPLOYMENT+"/"+obj)
        #ydump("tst_wait{}_output_{}.yaml".format(rc,obj),r) ; rc = rc+1

        if test_dep_generation(r, patch_gen):
            break

    if w.expired:
        raise AdjustError("update of {} failed, timed out waiting for k8s object update".format(obj), status="failed", reason="adjust-failed")

    dbg_log('waiting for progress: deployment {}, generation {}'.format(obj, patch_gen))

    p = 0.0 #

    m = "waiting for progress from k8s {}".format(obj)

    w = waiter(wait_for_progress, 2)
    c = float(c)
    err = "(wait skipped)"
    while w.wait():
        r = k_get(appname, DEPLOYMENT+"/"+obj)
        print_progress(int((c+p)*part*100), m)
        p, err = test_dep_progress(r)
        if p == 1.0:
            return # all done
        if err:
            break

    # loop ended, timed out:
    raise AdjustError("update of {} failed: timed out waiting for replicas to come up, status: {}".format(obj, err), status="failed", reason="start-failed")

rsrc_map = {"mem":("limits", "memory"), "cpu":("limits", "cpu")}
def set_rsrc(cp, sn, sv):
    r1, r2 = rsrc_map[sn]
    if sn == "mem":
        sv = str(sv) + 'Gi'     # internal memory representation is in GiB
    else:
        sv = str(sv)
    cp.setdefault("resources", {}).setdefault(r1, {})[r2] = sv

def _value(x):
    if isinstance(x, dict) and "value" in x:
        return x["value"]
    return x

def update(appname, data, print_progress):
    d = read_desc()
    # we'll need the raw k8s api data to see the container names (setting names for a single-container
    # pod will include only the deployment(=pod) name, not the container name)
    _, raw = raw_query(appname, d)

    # convert k8s list of deployments into map
    r2 = {}
    for r in raw:
        r2[r["metadata"]["name"]] = r

    raw = r2

    patchlst = {}
    # NB: app-wide settings not supported

    cfg = data.get("control", {})
    # TODO: new item: cfg.get("on_fail", "keep") # valid: keep, rollback, destroy
    # TODO: new item: cfg.get("settlement", 0)
    # TODO: new item: cfg.get("userdataa", {}).get("deployment", None) # ref app name

    # step-down in data if a 'state' key is provided at the top (FIXME: off-spec)
    if 'state' in data:
        data = data['state']

    for cn, cd in data.get("application", {}).get("components", {}).items():
        settings = cd.get("settings", {})
        if not settings: continue
        patches = {}
        replicas = None
        cont = None

        full_cn = cn
        if '/' in cn:
            cn, cont = cn.split('/', 1)

        dflt_cont = raw[cn]["spec"]["template"]["spec"]["containers"][0]["name"] # chk for KeyError FIXME
        cont = cont or dflt_cont

        comp = d['application']['components'].get(full_cn, {})

        command = check_component_section(comp, 'command')
        if command:
            if command.get('encoder'):
                cp = patches.setdefault(cont, {})
                cp['command'], encoded_settings = encode_encoder(settings, command['encoder'], expected_type=list)

                # Prevent encoded settings from further processing
                for setting in encoded_settings:
                    del settings[setting]

        env = check_component_section(comp, 'env')
        if env:
            for en, ev in env.items():
                cp = patches.setdefault(cont, {})
                if ev.get('encoder'):
                    val, encoded_settings = encode_encoder(settings, ev['encoder'], expected_type=str)
                    patch_env = cp.setdefault("env", [])
                    patch_env.append({"name": en,"value": val})

                    # Prevent encoded settings from further processing
                    for setting in encoded_settings:
                        del settings[setting]
                elif issetting(ev):
                    patch_env = cp.setdefault("env", [])
                    patch_env.append({"name": en, "value": str(settings[en]['value'])})
                    del settings[en]

        # Settings and env vars
        for sn, _sv in settings.items():
            sv = _value(_sv) # compatibility: allow a scalar, but also work with {"value": {anything}}
            cp = patches.setdefault(cont,{})
            if sn in ("mem", "cpu"):
                #
                set_rsrc(cp, sn, sv)
                continue
            elif sn == "replicas":
                replicas = int(sv)
            else: # env var setting
                patch_env = cp.setdefault("env", [])
                patch_env.append({"name":sn, "value":str(sv)})

        patch = patchlst.setdefault(cn, {})
        if patches: # convert to array
            cp = patch.setdefault('spec', {}).setdefault('template', {}).setdefault('spec', {}).setdefault('containers', [])
            for n, v in patches.items():
                v["name"] = n
                cp.append(v)
        if replicas is not None:
            patch.setdefault("spec", {})["replicas"] = replicas

    # NOTE: optimization possible: apply all patches first, then wait for them to complete (significant if making many changes at once!)

    # NOTE: it seems there's no way to update multiple resources with one 'patch' command (though -f accepts a directory, not sure how -f=dir works; maybe all listed resources get the *same* patch from the cmd line - not what we want)
    # execute patch commands
    c = 0
    for n, v in patchlst.items():
        # ydump("tst_before_output_{}.yaml".format(n), k_get(appname, DEPLOYMENT + "/" + n))
        # run: kubectl patch deployment[.v1.apps] $n -p "{jsondata}"
        patchstr = json_enc(v)
        try:
            patch_r = k_patch(appname, DEPLOYMENT, n, patchstr)
        except Exception as e: # TODO: limit to expected errors
            raise AdjustError(str(e), status="failed", reason="adjust-failed")
        p, _ = test_dep_progress(patch_r)
        if test_dep_generation(patch_r, patch_r["metadata"]["generation"]) and p == 1.0:
            # patch made no changes, skip wait_for_update:
            c = c + 1
            continue

        # ydump("tst_patch_output_{}.yaml".format(n), patch_r)

        # wait for update to complete (and print progress)
        # timeout default is set to be slightly higher than the default K8s timeout (so we let k8s detect progress stall first)
        try:
            wait_for_update(appname, n, patch_r["metadata"]["generation"], print_progress, c, len(patchlst), cfg.get("timeout", 630))
        except AdjustError as e:
            if e.reason != "start-failed": # not undo-able
                raise
            onfail = cfg.get("on_fail", "keep") # valid values: keep, destroy, rollback (destroy == scale-to-zero, not supported)
            if onfail == "rollback":
                try:
                    subprocess.call(kubectl(appname, "rollout", "undo", DEPLOYMENT+"/"+n))
                    print("UNDONE", file=sys.stderr)
                except subprocess.CalledProcessError:
                    # progress msg with warning TODO
                    print("undo for {} failed: {}".format(n, e), file=sys.stderr)
            raise
        c = c+1

# spec_id and version_id should be tested without settlement_time, too - TODO

    # post-adjust settlement, if enabled
    testdata0, raw = raw_query(appname, d)
    settlement_time = cfg.get("settlement", 0)
    mon0 = testdata0["monitoring"]

    if mon0["version_id"] != mon0["ref_version_id"]:
        raise AdjustError("application version does not match reference version", status="aborted", reason="version-mismatch")

# aborted status reasons that aren't supported: ref-app-inconsistent, ref-app-unavailable

    if not settlement_time:
        return {"monitoring":mon0, "status":"ok", "reason":"success"}

# TODO: adjust progress accounting when there is settlement_time!=0

    # wait and watch the app, checking for changes
    w = waiter(settlement_time, delay=min(settlement_time, 30)) # NOTE: delay between tests may be made longer than the delay between progress reports
    while w.wait():
        testdata, raw = raw_query(appname, d)
        mon = testdata["monitoring"]
        # compare to initial mon data set
        if mon["runtime_id"] != mon0["runtime_id"]: # restart detected
            # TODO: allow limited number of restarts? (and how to distinguish from rejected/unstable??)
            raise AdjustError("component(s) restart detected", status="transient-failure", reason="app-restart")
# TODO: what to do with version change?
#        if mon["version_id"] != mon0["version_id"]:
#            raise AdjustError("application was modified unexpectedly during settlement", status="transient-failure", reason="app-update")
        if mon["spec_id"] != mon0["spec_id"]:
            raise AdjustError("application configuration was modified unexpectedly during settlement", status="transient-failure", reason="app-update")
        if mon["ref_spec_id"] != mon0["ref_spec_id"]:
            raise AdjustError("reference application configuration was modified unexpectedly during settlement", status="transient-failure", reason="ref-app-update")
        if mon["ref_runtime_count"] != mon0["ref_runtime_count"]:
            raise AdjustError("", status="transient-failure", reason="ref-app-scale")

    # update() return

# cancel not supported
#def cancel(signum,frame):
#    if not wait_in_progress:
#        sys_exit(1)
#    print ("aborting operation...",file=sys.stderr)

VERSION = "1.1"

class K8sAdjust(Adjust):

    def _progress(self, progress, message):
        """adapter for the default base class implementation of progress message"""
        self.progress = progress
        self.print_progress(message=message)

    def query(self):
        try:
            d = read_desc()
        except ConfigError as e:
            raise AdjustError(str(e), reason="unknown") # maybe we should introduce reason=config (or even a different status class, instead of 'failed')
        d.pop("driver", None)
        r = query(self.app_id, d)
        return r

    def adjust(self, data):
        try:
            r = update(self.app_id, data, self._progress)
        except ConfigError as e:
            raise AdjustError(str(e), reason="unknown") # maybe we should introduce reason=config (or even a different status class, instead of 'failed')
        # all other exceptions: default handler - stack trace and sys.exit(1)
        return r


if __name__ == "__main__":
#    signal.signal(signal.SIGUSR1, cancel)
#    signal.signal(signal.SIGTERM, cancel)
#    signal.signal(signal.SIGINT, cancel)

    K8sAdjust(
        VERSION,
        "K8s driver for OCO servo.\n"
        "Note: set OPTUNE_USE_DEFAULT_NAMESPACE=1 environment var when embedded into app",
        supports_cancel=False,
        progress_interval=None).run()

# TBD: no support for multiple apps with different descriptors (desc file /app.yaml is not app-specific)
